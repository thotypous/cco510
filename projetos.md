---
layout: page
title: Projetos
---

## Projeto 1 -- *por problemas*

O objetivo do primeiro projeto é estudar, de forma prática, estruturas de dados e algoritmos mais complexos que os abordados em aula e na prova. Para isso, serão utilizados problemas de maratonas de programação.

### Projetos

1. [UVa 11487 - Gathering Food](https://uva.onlinejudge.org/external/114/11487.pdf)
2. [UVa 11402 - Ahoy, Pirates](https://uva.onlinejudge.org/external/114/11402.pdf)
3. [UVa 11060 - Beverages](https://uva.onlinejudge.org/external/110/11060.pdf)
4. [UVa 10600 - ACM Contest and Blackout](https://uva.onlinejudge.org/external/106/10600.pdf)
5. [UVa 12125 - March of the Penguins](https://uva.onlinejudge.org/external/121/12125.pdf)
6. [UVa 10888 - Warehouse](https://uva.onlinejudge.org/external/108/10888.pdf)

### Distribuição dos temas

Veja no [Doodle](https://doodle.com/poll/tceuz9723ve4nrgi).

### Instruções

* Cada grupo deve preparar uma solução original para o problema (plágio não será tolerado).
  * O código deve ser enviado ao professor até um dia antes da apresentação.
  * O código deve ser testado e passar na submissão do UVa.
* A apresentação (de 20 a 30 minutos) deverá abordar, ao menos:
  * Assuntos teóricos necessários ao entendimento da solução.
  * Aplicação ao problema.
  * Complexidade assintótica da solução.
  * Posição da solução da equipe no *ranking* do UVa (desempenho com relação a soluções submetidas por outros usuários).
  * Dificuldades de implementação.

### Bibliografia sugerida

* [HALIM, S.; HALIM, F. Competitive Programming 3. Lulu, 2013.](https://cpbook.net)


## Projeto 2 -- *por temas*

O objetivo do segundo projeto é abordar temas avançados que não façam parte do programa da maratona de programação, ou que sejam difíceis de encontrar em problemas da maratona.

### Projetos

1. Busca de strings: Aho-Corasick e Rabin-Karp.
2. Árvores especiais: WAVL e splay trees.
3. Estruturas de dados usadas em índices de bancos de dados: B-tree, R-tree, hash-based index, etc. Estudo de sua utilização em SGBDs abertos: PostgreSQL, MySQL, SQLite, BerkeleyDB, etc.
4. *Pointer-ownership* versus implementação de estruturas de dados. Implementação de alguma estrutura não abordada em [Learn Rust by writing Entirely Too Many Linked Lists](https://github.com/rust-unofficial/too-many-lists).
5. *Lock-free data structures*.
6. Bloom e [inverted bloom](https://arxiv.org/abs/0704.3313).

### Distribuição dos temas

Veja no [Doodle](https://doodle.com/poll/vqn86tbzxw6ytnd8).

### Instruções

* Cada grupo deve preparar uma implementação original de estruturas de dados e algoritmos relacionados ao tema (plágio não será tolerado).
  * O código deve ser enviado ao professor até um dia antes da apresentação.
  * O código deve acompanhar instruções para compilação e casos de teste.
  * O código deve ter sido testado e não deve apresentar erros de memória.
* A apresentação (de 20 a 30 minutos) deverá abordar, ao menos:
  * Discussão teórica do tema.
  * Discussão de aplicações práticas.
  * Complexidade assintótica dos algoritmos envolvidos.
  * Dificuldades de implementação.
  * Medidas de desempenho reais sobre o código entregue pelo grupo.
